import React from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import ScreenLayout from '../../ScreenLayout';
import { getNextScreen, getPreviousScreen, isFirstScreen } from '../../../utils/navigationUtils';
import { Calendar, CheckCircle } from 'lucide-react';

/**
 * EmploymentSummaryScreen - Section 5, Employment History Summary
 *
 * Shows a visual timeline/summary of all employment periods
 * Matches the format of Address ReviewScreen with vertical timeline
 */
const EmploymentSummaryScreen = ({
  currentData,
  updateField,
  userRole
}) => {
  const navigate = useNavigate();
  const location = useLocation();

  // Determine if this is sponsor or beneficiary based on URL
  const isSponsor = location.pathname.includes('section-5-employment') &&
                    !location.pathname.includes('beneficiary');
  const prefix = isSponsor ? 'sponsor' : 'beneficiary';
  const personName = isSponsor ? 'You' : (currentData.beneficiaryFirstName || "Beneficiary");

  // Get timeline entries
  const timelineEntriesField = isSponsor ? 'sponsorTimelineEntries' : 'beneficiaryTimelineEntries';
  const entries = (currentData[timelineEntriesField] || []).filter(entry => entry.type);

  // Format date
  const formatDate = (dateStr) => {
    if (!dateStr) return 'Not specified';
    const date = new Date(dateStr);
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
  };

  // Calculate coverage and gaps
  const calculateCoverage = () => {
    if (entries.length === 0) return { gaps: [], complete: false, coveragePercent: 0 };

    const today = new Date();
    const fiveYearsAgo = new Date();
    fiveYearsAgo.setFullYear(today.getFullYear() - 5);

    // Create periods from entries
    const periods = entries.map(entry => {
      const start = new Date(entry.startDate);
      const end = entry.isCurrent || !entry.endDate ? today : new Date(entry.endDate);
      return { start, end };
    });

    // Sort periods by start date
    periods.sort((a, b) => a.start - b.start);

    // Merge overlapping periods
    const merged = [];
    for (const period of periods) {
      if (merged.length === 0) {
        merged.push({ ...period });
      } else {
        const last = merged[merged.length - 1];
        if (period.start <= last.end) {
          // Overlapping or adjacent - merge
          last.end = period.end > last.end ? period.end : last.end;
        } else {
          merged.push({ ...period });
        }
      }
    }

    // Find gaps
    const gaps = [];

    // Check gap before first period
    if (merged.length > 0 && merged[0].start > fiveYearsAgo) {
      gaps.push({
        start: fiveYearsAgo,
        end: merged[0].start
      });
    }

    // Check gaps between periods
    for (let i = 0; i < merged.length - 1; i++) {
      const currentEnd = merged[i].end;
      const nextStart = merged[i + 1].start;
      if (nextStart > currentEnd) {
        gaps.push({
          start: currentEnd,
          end: nextStart
        });
      }
    }

    return { gaps, complete: gaps.length === 0 };
  };

  const coverage = calculateCoverage();

  // Format date
  const formatDate = (dateStr) => {
    if (!dateStr) return 'Not specified';
    const date = new Date(dateStr);
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
  };

  // Format gap duration
  const formatGapDuration = (start, end) => {
    const startDate = new Date(start);
    const endDate = new Date(end);
    const diffMs = endDate - startDate;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    if (diffDays === 1) return '1 day';
    if (diffDays < 30) return `${diffDays} days`;

    const diffMonths = Math.floor(diffDays / 30);
    const remainingDays = diffDays % 30;

    if (diffMonths < 12) {
      if (remainingDays === 0) return `${diffMonths} month${diffMonths !== 1 ? 's' : ''}`;
      return `${diffMonths} month${diffMonths !== 1 ? 's' : ''} ${remainingDays} day${remainingDays !== 1 ? 's' : ''}`;
    }

    const years = Math.floor(diffMonths / 12);
    const remainingMonths = diffMonths % 12;

    if (remainingMonths === 0) return `${years} year${years !== 1 ? 's' : ''}`;
    return `${years} year${years !== 1 ? 's' : ''} ${remainingMonths} month${remainingMonths !== 1 ? 's' : ''}`;
  };

  const handleNext = () => {
    const nextPath = getNextScreen(location.pathname, userRole, currentData);
    if (nextPath) {
      navigate(nextPath);
    }
  };

  const handleBack = () => {
    const prevPath = getPreviousScreen(location.pathname, userRole, currentData);
    if (prevPath) {
      navigate(prevPath);
    }
  };

  const isFirst = isFirstScreen(location.pathname, userRole, currentData);

  // Group issues by category
  const getIssues = () => {
    const issues = [];

    if (entries.length === 0) {
      issues.push('No employment history provided');
      return issues;
    }

    // Check for incomplete entries
    const incompleteEntries = entries.filter(entry => {
      if (!entry.startDate) return true;
      if (!entry.isCurrent && !entry.endDate) return true;
      if (entry.type === 'working' && !entry.organization) return true;
      if (entry.type === 'seeking-work' && !entry.organization) return true;
      return false;
    });

    if (incompleteEntries.length > 0) {
      issues.push(`${incompleteEntries.length} employment period${incompleteEntries.length !== 1 ? 's have' : ' has'} incomplete information`);
    }

    // Check for gaps
    if (coverage.gaps.length > 0) {
      issues.push(`${coverage.gaps.length} gap${coverage.gaps.length !== 1 ? 's' : ''} in 5-year coverage`);
    }

    return issues;
  };

  const issues = getIssues();
  const isComplete = issues.length === 0;

  // Sort entries for display (current first, then by start date descending)
  const sortedEntries = [...entries].sort((a, b) => {
    const aIsCurrent = a.isCurrent || !a.endDate;
    const bIsCurrent = b.isCurrent || !b.endDate;

    if (aIsCurrent && !bIsCurrent) return -1;
    if (!aIsCurrent && bIsCurrent) return 1;

    const aStartDate = new Date(a.startDate || '1970-01-01');
    const bStartDate = new Date(b.startDate || '1970-01-01');
    return bStartDate - aStartDate;
  });

  return (
    <ScreenLayout
      showBackButton={!isFirst}
      onBack={handleBack}
      onNext={handleNext}
      nextButtonDisabled={!isComplete}
    >
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <h2 className="text-2xl font-semibold text-gray-900">
            Employment History Summary
          </h2>
          {isComplete && (
            <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
              <CheckCircle className="w-4 h-4 mr-1" />
              Complete
            </span>
          )}
        </div>

        {/* Status message */}
        <div className={`p-4 rounded-lg border ${isComplete ? 'bg-green-50 border-green-200' : 'bg-amber-50 border-amber-200'}`}>
          {isComplete ? (
            <p className="text-green-800">
              âœ… {personName === 'You' ? 'Your' : `${personName}'s`} 5-year employment history is complete with no gaps!
            </p>
          ) : (
            <div>
              <p className="text-amber-800 font-medium mb-2">
                âš ï¸ The highlighted sections below show where we still need more information.
              </p>
              <ul className="list-disc list-inside text-amber-700 text-sm space-y-1">
                {issues.map((issue, index) => (
                  <li key={index}>{issue}</li>
                ))}
              </ul>
            </div>
          )}
        </div>

        {/* Timeline */}
        <div className="bg-white border rounded-lg p-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center">
            <Briefcase className="w-5 h-5 mr-2" />
            5-Year Employment Timeline
          </h3>

          {/* Coverage status */}
          {entries.length > 0 && (
            <div className="mb-6 p-3 rounded border">
              {coverage.complete ? (
                <div className="text-green-600 text-sm">
                  âœ… Complete coverage - no gaps detected
                </div>
              ) : (
                <div className="space-y-2">
                  <div className="text-red-600 text-sm font-medium">
                    âŒ Coverage incomplete: {coverage.gaps.length} gap{coverage.gaps.length !== 1 ? 's' : ''} detected
                  </div>
                  <div className="ml-4 space-y-1">
                    {coverage.gaps.map((gap, index) => (
                      <div key={index} className="text-red-700 text-xs bg-red-50 px-2 py-1 rounded">
                        ğŸ“… Gap {index + 1}: {formatDate(gap.start)} to {formatDate(gap.end)} ({formatGapDuration(gap.start, gap.end)})
                      </div>
                    ))}
                  </div>
                  <div className="text-gray-600 text-xs">
                    ğŸ’¡ Go back to the previous screen to add work periods, education, or other activities to cover these gaps
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Employment entries */}
          <div className="space-y-3">
            {sortedEntries.length === 0 ? (
              <p className="text-gray-500 text-center py-8">
                No employment history added yet.
              </p>
            ) : (
              sortedEntries.map((entry, index) => {
                // Check if this entry overlaps with others
                const hasOverlaps = entries.filter(otherEntry => {
                  if (otherEntry === entry || !otherEntry.type) return false;

                  const entryStart = new Date(entry.startDate);
                  const entryEnd = (entry.isCurrent || !entry.endDate) ? new Date() : new Date(entry.endDate);
                  const otherStart = new Date(otherEntry.startDate);
                  const otherEnd = (otherEntry.isCurrent || !otherEntry.endDate) ? new Date() : new Date(otherEntry.endDate);

                  return entryStart <= otherEnd && entryEnd >= otherStart;
                }).length > 0;

                const typeIcons = {
                  'working': 'ğŸ’¼',
                  'in-education': 'ğŸ“š',
                  'seeking-work': 'ğŸ”',
                  'homemaker': 'ğŸ ',
                  'retired': 'ğŸŒ´',
                  'unable-to-work': 'ğŸ¥',
                  'military': 'ğŸª–',
                  'other': 'ğŸ“'
                };

                return (
                  <div key={index} className="flex items-start justify-between py-3 border-b border-gray-100 last:border-b-0">
                    <div className="flex-1">
                      <div className="flex items-center">
                        <span className="text-lg mr-2">{typeIcons[entry.type] || 'ğŸ“'}</span>
                        <span className="font-medium text-gray-900">
                          {getDisplayName(entry)}
                        </span>
                        {(entry.isCurrent || !entry.endDate) && (
                          <span className="ml-2 px-2 py-1 bg-green-100 text-green-800 text-xs rounded-full">
                            Current
                          </span>
                        )}
                        {hasOverlaps && (
                          <span className="ml-2 px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded-full">
                            Overlapping
                          </span>
                        )}
                      </div>
                      {entry.jobTitle && (
                        <p className="text-sm text-gray-600 ml-7">{entry.jobTitle}</p>
                      )}
                    </div>
                    <div className="text-sm text-gray-500 ml-4">
                      {formatDate(entry.startDate)} â†’ {(entry.isCurrent || !entry.endDate) ? 'Present' : formatDate(entry.endDate)}
                    </div>
                  </div>
                );
              })
            )}
          </div>
        </div>
      </div>
    </ScreenLayout>
  );
};

export default EmploymentSummaryScreen;
